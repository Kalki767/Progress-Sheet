# Problem: Minimize Malware Spread - https://leetcode.com/problems/minimize-malware-spread/

class UnionFind:
    def __init__(self,size):
        self.parents = {i:i for i in range(size)}
        self.size = {i:1 for i in range(size)}
    
    def findParent(self,u):
        if self.parents[u] == u:
            return u
        self.parents[u] = self.findParent(self.parents[u])
        return self.parents[u]
    
    def union(self,u,v):
        parent_u = self.findParent(u)
        parent_v = self.findParent(v)
        if parent_u == parent_v:
            return False
        if self.size[parent_u] > self.size[parent_v]:
            self.parents[parent_v] = parent_u
            self.size[parent_u] += self.size[parent_v]
        else:
            self.parents[parent_u] = parent_v
            self.size[parent_v] += self.size[parent_u]
        return True
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        '''Approach: Union Find. The problem asks to find a node to be cured among
        the infected ones so that by curing that node we can minimized the number
        of infected nodes in total. If two nodes are directly connected then they
        would both be infected if one of them are infected. So let's observe some
        things here from the given graph we might have multiple connected components.
        So in each component we need to know how many infected nodes there are. 
        Because technically since the nodes are connected we can make the whole
        nodes cured if they have only one infected node. If there is more than one
        infected node in one component whether we cure one of it or not the whole
        component will still be infected due to the other infected nodes. So for
        this case we will first build our graph count the infected nodes with their
        respective component and if there is only one infected node we check for it's
        size since there might be multiple connected components that have only one
        infected node we want to take the one with bigger size to minimize the
        total number of infected nodes. And which data structure is suitable for 
        handling connected components? Union Find! So we will build the graph and
        update our answer based on our graph. We will use union find by size to
        know the total number of nodes in one connected component.'''

        #Step1: Build the graph with multiple connected components
        rows = len(graph)
        cols = len(graph[0])
        union_find = UnionFind(rows)
        for row in range(rows):
            for col in range(cols):
                if graph[row][col] == 1 and row != col:
                    union_find.union(row,col)
        
        #Step2: For each infected node count the number of infected nodes in it's component
        infected = defaultdict(int)
        for node in initial:
            parent = union_find.findParent(node)
            infected[parent] += 1

        #Step3: Iterate through the infected nodes
        answer = [float('inf'), float('-inf')]
        res = []
        for node in initial:
            parent = union_find.findParent(node)
            if infected[parent] == 1: #if it's the only infected node in that component
                total_node = union_find.size[parent]
                if total_node > answer[1]: # if the size is greater update the answer node
                    answer = [node,total_node]
                elif total_node == answer[1] and answer[0] > node: #if they are equal take the minimum node
                    answer[0] = node
            else: #otherwise append the node to the result
                res.append(node)
        
        #if there is a node that's the only infected one in a component return it
        if answer[0] != float('inf'):
            return answer[0]
        res.sort()
        return res[0] #otherwise return the minimum node

        #Time Complexity: O(rows*cols) considering the union operation takes amortized O(1) time
        #Space Complexity: O(rows)